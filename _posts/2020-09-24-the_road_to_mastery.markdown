---
layout: post
title:      "The Road to Mastery"
date:       2020-09-24 17:48:05 +0000
permalink:  the_road_to_mastery
---

This module's project involved creating a web app using Ruby on Rails. Comparing Ruby on Rails makes Sinatra look like a Power Wheels Barbie Jeep Wrangler, *still really cool* but not nearly enough power for the big road. Ruby on Rails has the power to make arduous HTML code into beautiful, magical macros. Building on the Model, View, Controller and RESTful routes that I had learned in the Sinatra module I created a cleaner, more functional web app. In my Sinatra app I was proud to figure out how to allow users to uploading\viewing pictures. In Ruby on Rails there is Active Storage which is a great module to use that will make it easier for users to upload pictures, and for me the developer to manipulate the image and change it's size, store different resolutions, and display them with ease.

A new concept which although wasn't a requirement for the project, still ended up being a requirement for me to meet my own expectations with this project, is **Polymorphic associations**. The Ruby on Rails Guide describes a polymorphic association is when a model can belong to more than one other model, on a single association. In their example they described how an Employee model, and a Product model can `have_many :pictures, :as => :imageable` with the Picture model being polymorphic. In other words, the model Picture can be associated with employees and products. I used polymorphic associations to make my comments model make more sense. 

Originally I had a table for comments, replies, and a join table comment_replies. This proved to be a pain, and more difficult to work with. When finding out about polymorphic associations it imediately became obvious that was the route I should take. The idea is that a users can make comments about pictures, and users can reply to comments. Logically this means that a comment has to be associated with a picture...and itself! 
My Picture model includes `has_many :comments, as: :commentable` and in my Comment model includes `belongs_to :commentable, polymorphic: true` and `has_many :comments, as: :commentable`. Also, comments table schema has `t.integer "commentable_id"` and `t.string "commentable_type"` as two table attributes. In plain English what this is doing is storing what the parent object is to the comment. If I am doing a top level comment (commenting a picture) then the Comment instance will have `commentable_id = the picture.id` and `commentable_type = "Picture"`. This allows the model and table to understand that this instance of Comment is a comment about picture. If I make a reply to that comment I am making a comment about a comment. So we would see `commentable_id = comment i'm replying to's comment.id` and `commentable_type = "Comment"`, this is done automatically! It is a little hard to grasp at first, but by using `as: :commentable` allows the comment to comment on the comment... Confused yet? Let me try and break this down a little further.
For a reply to a comment, we take the comment that we want to reply to and give it a new name, the standard way is to call it something-able, so a comment should be commentable. So for the sake of my sanity, let's store what i'm doing in variables and let's say I am looking at a `Picture(:id => 3, :title => "My new car", :description => "1998 Nissan Sentra, 0->60mph in 12.5 seconds aww yeah")` and store that as `random_picture` and I want to make a comment, it would look like `Comment(:id => 1, :content => "Nice whip", :commentable_id => 3, :commentable_type => "Picture")` as `my_comment`. You can see that commentable_id is the ID of the picture, and we know it is a comment about a picture because it tells us in commentable_type. If we wanted to find the parent item we would see `:commentable_type => "Picture"` so we would search for an Instance of Picture, and find the picture by `Picture.find_by(my_comment.commentable_id)`. The easy shorthand way is to simply call the method .commentable on an instance to see what it's parent is.
From me making a comment we can see it in the instance by doing `random_picture.comments` and it'll show an array of comments containing my 1 comment.
Well now you want to reply to `my_comment`. I can do that by saying `commentable = my_comment`. Why do I do this? Well, because if you remember we made our Comment model `has_many :comments, as :commentable` and with that we can do `commentable.comments`! Our comment, can have many comments, one of which will be YOUR reply and can look like this: `your_reply = commentable.comments.new(:id => 2, :content => "Oh hai! Thanks for the comment!", :commentable_id => 1, :commentable_type => "Comment")`. From the information about `your_reply` we can see that it is a comment about a comment because the `your_reply.commentable_type is "Comment"` and we know that comment (my_comment) has an id of 1 because `your_reply.commentable_id is 1`.
If you're still having trouble grasping this that's okay it is pretty advanced. *Luckily for you I am available for hire and have big brain ideas, contact me...*

Another vast improvement from my last project was using partials to render content. Instead of having to write out the same stuff for pages like New and Edit, or Comments I could write it once, and then refer to it in whatever views I want by simply calling it `<%= render partial: 'layouts/comment', collection: @picture.comments %>` and the crazy part is in order to show comments comments (like `my_comment.comments` above) I actually called a partial, within a partial! It's got that same magic feeling of recursive functions.

Not only was I able to make an even better functioning program than my previous, but I used valuable gems and power ActiveRecord to make my code DRYer and better. I found that I felt a certain sense of accomplishment when I completed this project, not because it was better than my last, but because my previous project taught me the underlying concepts in the tools I use now, giving me an ability to use these tools better than those who would just use them without knowing *how* they work, which will end up leaving them to struggle when something doesn't work.
